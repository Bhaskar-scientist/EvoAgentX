import yaml
import asyncio
from abc import ABC, abstractmethod
from pydantic import Field
from typing import Union, Optional, Type, Callable, List

from ..core.parser import Parser
from .model_configs import LLMConfig
from ..core.module_utils import (
    parse_json_from_text, 
    get_type_name,
    parse_xml_from_text,
    parse_data_from_text
)


PARSER_VALID_MODE = ["str", "json", "xml", "title", "custom"]

class LLMOutputParser(Parser):

    """
    a basic LLM output parser that directly store the text generated by LLM in the .text attribute.
    """
    content: str = Field(default=None, exclude=True, description="the text generated by LLM")

    @classmethod
    def get_attrs(cls, return_type: bool = False) -> List[Union[str, tuple]]:
        """
        return the attributes of the LLMOutputParser class. Exclude ["class_name", "content"] by default. 

        Args:
            return_type (bool): whether to return the type of the attributes.
        
        Returns:
            List[Union[str, tuple]]: the attributes of the LLMOutputParser class. 
                If `return_type` is True, return a list of tuples, where each tuple contains the attribute name and its type. 
                Otherwise, return a list of attribute names.
        """
        attrs = [] 
        exclude_attrs = ["class_name", "content"]
        for field, field_info in cls.model_fields.items():
            if field not in exclude_attrs:
                if return_type:
                    field_type = get_type_name(field_info.annotation)
                    attrs.append((field, field_type))
                else:
                    attrs.append(field)
        return attrs
    
    @classmethod
    def get_attr_descriptions(cls) -> dict:
        """
        return the attributes and its description
        """
        attrs = cls.get_attrs()
        results = {} 
        for field_name, field_info in cls.model_fields.items():
            if field_name not in attrs:
                continue
            field_desc = field_info.description if field_info.description is not None else "None"
            results[field_name] = field_desc
        return results

    @classmethod
    def get_content_data(cls, content: str, parse_mode: str = "json", parse_func: Optional[Callable] = None, **kwargs) -> dict:

        """
        parse the LLM generated content into a dict.

        Args:
            content (str): the content to parse.
            mode (str): the mode to parse the content, must be one of: ['str', 'json', 'xml', 'title', 'custom'].
            parse_func (Callable, optional): the function to parse the content, only valid when `mode` is 'custom'. 
        
        Returns:
            dict: the parsed content.
        """

        attrs = cls.get_attrs()
        if len(attrs) <= 0:
            return {} 
        
        if parse_mode == "str":
            parse_func = cls._parse_str_content
        elif parse_mode == "json":
            parse_func = cls._parse_json_content
        elif parse_mode == "xml":
            parse_func = cls._parse_xml_content
        elif parse_mode == "title":
            parse_func = cls._parse_title_content
        elif parse_mode == "custom":
            if parse_func is None:
                raise ValueError("`parse_func` must be provided when `parse_mode` is 'custom'.")
        else:
            raise ValueError(f"Invalid value '{parse_mode}' detected for `parse_mode`. Available choices: {PARSER_VALID_MODE}")
        data = parse_func(content=content, **kwargs)
        return data
    
    @classmethod
    def _parse_str_content(cls, content: str, **kwargs) -> dict:
        """
        set all attributes to the generated content. 

        Args:
            content (str): the content to parse.
        
        Returns:
            dict: the parsed content. 
        """
        # if `parse_mode=str` in llm.generate(), it will set all the defined parameters to `content`
        attrs = cls.get_attrs()
        return {attr: content for attr in attrs}
    
    @classmethod 
    def _parse_json_content(cls, content: str, **kwargs) -> dict:

        extracted_json_list = parse_json_from_text(content)
        if len(extracted_json_list) > 0:
            json_str = extracted_json_list[0] # only use the first JSON
            try:
                data = yaml.safe_load(json_str)
                if not isinstance(data, dict):
                    if isinstance(data, list):
                        # LLM returns a list of JSON strings, without specifying the attribute name
                        attrs = cls.get_attrs()
                        if len(attrs) == 1:
                            # if there is only one attribute, use it as the attribute name 
                            return {attrs[0]: data}
                        else:
                            # if there are multiple attributes, raise an error
                            raise ValueError("The generated content is a list of JSON strings, but the attribute name for the list is not specified. You should instruct the LLM to specify the attribute name for the list.")
                    else:
                        raise ValueError(f"The generated content is not a valid JSON string:\n{json_str}")
            except Exception:
                raise ValueError(f"The generated content is not a valid JSON string:\n{json_str}")
        else:
            raise ValueError(f"The following generated content does not contain JSON string!\n{content}")
        
        return data
    
    @classmethod
    def _parse_xml_content(cls, content: str, **kwargs) -> dict:
        attrs_with_types: List[tuple] = cls.get_attrs(return_type=True)
        data = {} 
        for attr, attr_type in attrs_with_types:
            attr_raw_value_list = parse_xml_from_text(text=content, label=attr)
            if len(attr_raw_value_list) > 0:
                attr_raw_value = attr_raw_value_list[0]
                try:
                    attr_value = parse_data_from_text(text=attr_raw_value, datatype=attr_type)
                except Exception:
                    raise ValueError(f"Cannot parse text: {attr_raw_value} into {attr_type} data!")
            else:
                raise ValueError(f"The following generated content does not contain xml label <{attr}>xxx</{attr}>!\n{content}")
            data[attr] = attr_value
        return data
    
    @classmethod
    def _parse_title_content(cls, content: str, title_format: str = "## {title}", **kwargs) -> dict:
        """
        parse the content with title format. e.g.
        ## title1
        content1
        ## title2
        content2

        Args:
            content (str): the content to parse.
            title_format (optional, str): the format of the title, default is "## {title}".

        Returns:
            dict: the parsed content.
        """
        attrs: List[str] = cls.get_attrs()
        if not attrs:
            return {}
        
        output_titles = [title_format.format(title=attr) for attr in attrs]

        def is_output_title(text: str):
            return any(text.strip().startswith(title) for title in output_titles)

        data = {}
        current_output_name: str = None
        current_output_content: list = None
        for line in content.split("\n"):
            if is_output_title(line):
                if current_output_name is not None and current_output_content is not None:
                    data[current_output_name] = "\n".join(current_output_content)
                current_output_content = []
                current_output_name = line.replace("#", "").strip()
            else: 
                if current_output_content is not None:
                    current_output_content.append(line)
        if current_output_name is not None and current_output_content is not None:
            data[current_output_name] = "\n".join(current_output_content)
        return data
    
    @classmethod
    def parse(cls, content: str, parse_mode: str = "json", parse_func: Optional[Callable] = None, **kwargs) -> "LLMOutputParser":
        """
        the method used to parse text generated by LLM. This method only passes the input text to the .text attribute. 
        """
        if parse_mode not in PARSER_VALID_MODE:
            raise ValueError(f"'{parse_mode}' is an invalid value for `parse_mode`. Available choices: {PARSER_VALID_MODE}.")
        if not isinstance(content, str):
            raise ValueError(f"The input to {cls.__name__}.parse should be a str, but found {type(content)}.")
        data = cls.get_content_data(content=content, parse_mode=parse_mode, parse_func=parse_func, **kwargs)
        data.update({"content": content})
        parser = cls.from_dict(data, **kwargs)
        # parser.content = content
        return parser

    def __str__(self) -> str:
        return self.to_str()
    
    def to_str(self, **kwargs) -> str:
        return self.content
    
    def get_structured_data(self) -> dict:
        attrs = type(self).get_attrs()
        data = self.to_dict(ignore=["class_name"])
        # structured_data = {attr: data[attr] for attr in attrs}
        structured_data = {key: value for key, value in data.items() if key in attrs}
        return structured_data



class BaseLLM(ABC):
    
    def __init__(self, config: LLMConfig, **kwargs):

        self.config = config
        self.kwargs = kwargs
        self.init_model()
    
    @abstractmethod
    def init_model(self):
        pass

    def __deepcopy__(self, memo):
        # return the same instance when deepcopy
        memo[id(self)] = self
        return self

    @abstractmethod
    def formulate_messages(self, prompts: List[str], system_messages: Optional[List[str]] = None) -> List[List[dict]]:
        """
        Converts input prompts into the chat format compatible with different LLMs.

        Args:
            prompts (List[str]): A list of user prompts that need to be converted.
            system_messages (Optional[List[str]]): An optional list of system messages that provide instructions or context to the model.
        
        Returns:
            List[List[dict]]: A list of message lists, where each inner list contains messages in the chat format required by LLMs. 
        """
        pass

    @abstractmethod
    def single_generate(self, messages: List[dict], **kwargs) -> str:
        """
        generate LLM output for a given prompt. 

        Args:
            prompt (str): the input to the LLM.
            generation_config (LLMGenerationConfig): the generation config for LLM.
        
        Returns:
            str: the generated output from LLM.
        """
        pass

    @abstractmethod
    def batch_generate(self, batch_messages: List[List[dict]], **kwargs) -> List[str]:
        """
        generate outputs for a batch of prompts. 

        Args: 
            prompts (List[str]): a batch of inputs to the LLM. 
            generation_config (LLMGenerationConfig): the generation config for LLM.            
        
        Returns:
            List[str]: a list of generated outputs from LLM.
        """
        pass
    
    async def single_generate_async(self, messages: List[dict], **kwargs) -> str:
        """
        Async version of single_generate.
        Generate LLM output for a given prompt asynchronously.
        Args:
            messages (List[dict]): the input messages to the LLM.
            **kwargs: Additional keyword arguments for generation configuration.
        
        Returns:
            str: the generated output from LLM.
        """
        # Default implementation for backward compatibility
        loop = asyncio.get_event_loop()
        result = await loop.run_in_executor(None, self.single_generate, messages, **kwargs)
        return result
    
    async def batch_generate_async(self, batch_messages: List[List[dict]], **kwargs) -> List[str]:
        """
        Async version of batch_generate.
        Generate outputs for a batch of prompts asynchronously.
        Args: 
            batch_messages (List[List[dict]]): a batch of input messages to the LLM.
            **kwargs: Additional keyword arguments for generation configuration.
        
        Returns:
            List[str]: a list of generated outputs from LLM.
        """
        # Default implementation for backward compatibility
        tasks = [self.single_generate_async(messages, **kwargs) for messages in batch_messages]
        return await asyncio.gather(*tasks)
    
    def parse_generated_text(self, text: str, parser: Optional[Type[LLMOutputParser]]=None, parse_mode: Optional[str] = "json", parse_func: Optional[Callable] = None, **kwargs) -> LLMOutputParser:
        """
        use parser to obtain a structured output. 

        Args: 
            text (str): a text that potentially contains structured string. 
            parser (Type[LLMOutputParser]): an LLMOutputParser class. 
        
        Returns:
            LLMOutputParser: an LLMOutputParser object. 
        
        Note: 
            use parser.parse(text) to obtain the result. 
        """
        if not parser:
            parser = LLMOutputParser
        return parser.parse(text, parse_mode=parse_mode, parse_func=parse_func)

    def parse_generated_texts(self, texts: List[str], parser: Optional[Type[LLMOutputParser]]=None, parse_mode: Optional[str] = "json", parse_func: Optional[Callable] = None, **kwargs) -> List[LLMOutputParser]:

        parsed_results = [self.parse_generated_text(text=text, parser=parser, parse_mode=parse_mode, parse_func=parse_func, **kwargs) for text in texts]
        return parsed_results

    def _prepare_messages(
        self,
        prompt: Optional[Union[str, List[str]]] = None,
        system_message: Optional[Union[str, List[str]]] = None,
        messages: Optional[Union[List[dict],List[List[dict]]]] = None,
    ) -> tuple[List[List[dict]], bool]:
        """
        Prepare and validate messages for generation.

        Args:
            prompt: Input prompt(s) to the LLM.
            system_message: System message(s) for the LLM.
            messages: Chat message(s) for the LLM.

        Returns:
            tuple: (prepared_messages, is_single_generate)
                - prepared_messages: List of message lists ready for generation
                - is_single_generate: Boolean indicating if this is a single generation
        """
        if not (prompt or messages):
            raise ValueError("Either 'prompt' or 'messages' must be provided.")
        if prompt and messages:
            raise ValueError("Both 'prompt' and 'messages' are provided. Please provide only one of them.")

        single_generate = False
        if messages is not None:
            if not messages:  # empty messages
                return [], False
            if isinstance(messages[0], dict):
                single_generate = True
                messages = [messages]
            return messages, single_generate

        if isinstance(prompt, str):
            single_generate = True
            prompt = [prompt]
            if system_message:
                if not isinstance(system_message, str):
                    raise TypeError(f"'system_message' should be a string when passing a single prompt, but found {type(system_message)}.")
                system_message = [system_message]
        elif isinstance(prompt, list) and all(isinstance(p, str) for p in prompt):
            single_generate = False
            if not prompt:  # empty prompt
                return [], False
            if system_message:
                if not isinstance(system_message, list) or len(prompt) != len(system_message):
                    raise ValueError(f"'system_message' should be a list of string when passing multiple prompts and the number of prompts ({len(prompt)}) must match the number of system messages ({len(system_message)}).")
        else:
            raise ValueError(f"'prompt' must be a str or List[str], but found {type(prompt)}.")
        
        prepared_messages = self.formulate_messages(prompts=prompt, system_messages=system_message)
        return prepared_messages, single_generate

    def generate(
        self,
        prompt: Optional[Union[str, List[str]]] = None,
        system_message: Optional[Union[str, List[str]]] = None,
        messages: Optional[Union[List[dict],List[List[dict]]]] = None,
        parser: Optional[Type[LLMOutputParser]] = None,
        parse_mode: Optional[str] = "json", 
        parse_func: Optional[Callable] = None,
        **kwargs
    ) -> Union[LLMOutputParser, List[LLMOutputParser]]:
        """
        generate LLM output(s) for (a) prompt(s)/messages and parsed the result into an LLMOutputParser object. 

        Args:
            prompt (Union[str, List[str]]): the input to the LLM. 
            system_message (str): the system message for the LLM. 
            messages: (Union[List[dict],List[List[dict]]]): the chat message for the LLM. 
            parser (Optional[Type[LLMOutputParser]]): A LLMOutputParser (sub)class used to parse the LLM output.
                This class should implement .parse() method to parse the output. If None, LLMOutputParser will be used by default.
            parse_mode: (Optional[str]): The mode to parse the LLM output.
            parse_func: (Optional[Callable]): A function to parse the LLM output.
        
        Note:
            Either prompt or messages must be provided. Raise an error if both prompt and messages are provided or none of them is provided. 
            If parser is None, use LLMOutputParser by default. 
            Need to calculate the cost of an LLM call!
        """
        prepared_messages, single_generate = self._prepare_messages(prompt, system_message, messages)
        if not prepared_messages:  # Handle empty messages case
            return []

        generated_texts = self.batch_generate(batch_messages=prepared_messages, **kwargs)
        parsed_outputs = self.parse_generated_texts(texts=generated_texts, parser=parser, parse_mode=parse_mode, parse_func=parse_func, **kwargs)
        return parsed_outputs[0] if single_generate else parsed_outputs
    
    async def generate_async(
        self,
        prompt: Optional[Union[str, List[str]]] = None,
        system_message: Optional[Union[str, List[str]]] = None,
        messages: Optional[Union[List[dict],List[List[dict]]]] = None,
        parser: Optional[Type[LLMOutputParser]] = None,
        parse_mode: Optional[str] = "json", 
        parse_func: Optional[Callable] = None,
        **kwargs
    ) -> Union[LLMOutputParser, List[LLMOutputParser]]:
        """
        Async version of generate.
        Generate LLM output(s) for (a) prompt(s)/messages and parse the result into an LLMOutputParser object.
        Args:
            prompt (Union[str, List[str]]): the input to the LLM. 
            system_message (str): the system message for the LLM. 
            messages: (Union[List[dict],List[List[dict]]]): the chat message for the LLM. 
            parser (Optional[Type[LLMOutputParser]]): A LLMOutputParser (sub)class used to parse the LLM output.
                This class should implement .parse() method to parse the output. If None, LLMOutputParser will be used by default.
        
        Returns:
            Union[LLMOutputParser, List[LLMOutputParser]]: Parsed output(s) from the LLM.
        """
        prepared_messages, single_generate = self._prepare_messages(prompt, system_message, messages)
        if not prepared_messages:  # Handle empty messages case
            return []

        generated_texts = await self.batch_generate_async(batch_messages=prepared_messages, **kwargs)
        parsed_outputs = self.parse_generated_texts(texts=generated_texts, parser=parser, parse_mode=parse_mode, parse_func=parse_func, **kwargs)
        return parsed_outputs[0] if single_generate else parsed_outputs


__all__ = ["LLMConfig", "BaseLLM", "LLMOutputParser"]

