import yaml
from copy import deepcopy
from abc import ABC, abstractmethod
from pydantic import Field
from typing import Union, Optional, Type, List

from ..core.parser import Parser
from ..core.module_utils import parse_json_from_text, extract_code_blocks
from ..core.registry import register_model
from .model_configs import LLMConfig


class LLMOutputParser(Parser):

    """
    a basic LLM output parser that directly store the text generated by LLM in the .text attribute.
    """
    content: str = Field(default=None, exclude=True, description="the text generated by LLM")

    @classmethod
    def get_attrs(cls):
        attrs = [] 
        exclude_attrs = ["class_name", "content"]
        for field, field_info in cls.model_fields.items():
            if field not in exclude_attrs:
                attrs.append(field)
        return attrs

    @classmethod
    def get_content_data(cls, content: str, **kwargs) -> dict:

        attrs = cls.get_attrs()
        if len(attrs) <= 0:
            return {} 
        
        extracted_json_list = parse_json_from_text(content)
        if len(extracted_json_list) > 0:
            json_str = extracted_json_list[0] # only use the first JSON
            try:
                data = yaml.safe_load(json_str)
                return data
            except:
                pass 
            try:
                code_blocks = extract_code_blocks(content) # extract json/python code blocks
                code_block = code_blocks[0]
                data = {attr: code_block for attr in attrs}
            except:
                data = {attr: content for attr in attrs}
        else:
            raise ValueError(f"The following generated content does not contain JSON string!\n{content}")
        
        return data
    
    @classmethod
    def parse(cls, content: str, **kwargs):
        """
        the method used to parse text generated by LLM. This method only passes the input text to the .text attribute. 
        """
        if not isinstance(content, str):
            assert f"The input to {cls.__name__}.parse should be a str, but found {type(content)}."
        data = cls.get_content_data(content, **kwargs)
        parser = cls.from_dict(data, **kwargs)
        parser.content = content
        return parser
    
    def to_str(self, **kwargs) -> str:
        return self.content
    
    def get_structured_data(self) -> dict:
        attrs = type(self).get_attrs()
        data = self.to_dict()
        structured_data = {attr: data[attr] for attr in attrs}
        return structured_data



class BaseLLM(ABC):
    
    def __init__(self, config: LLMConfig, **kwargs):

        self.config = config
        self.kwargs = kwargs
        self.init_model()
    
    @abstractmethod
    def init_model(self):
        pass

    @abstractmethod
    def single_generate(self, messages: List[dict], **kwargs) -> str:
        """
        generate LLM output for a given prompt. 

        Args:
            prompt (str): the input to the LLM.
            generation_config (LLMGenerationConfig): the generation config for LLM.
        
        Returns:
            str: the generated output from LLM.
        """
        pass

    @abstractmethod
    def batch_generate(self, messages: List[List[dict]], **kwargs) -> List[str]:
        """
        generate outputs for a batch of prompts. 

        Args: 
            prompts (List[str]): a batch of inputs to the LLM. 
            generation_config (LLMGenerationConfig): the generation config for LLM.            
        
        Returns:
            List[str]: a list of generated outputs from LLM.
        """
        pass

    @abstractmethod
    def parse_generated_text(self, text: str, parser: Optional[Type[LLMOutputParser]]=None, **kwargs) -> LLMOutputParser:
        """
        use parser to obtain a structured output. 

        Args: 
            text (str): a text that potentially contains structured string. 
            parser (Type[LLMOutputParser]): an LLMOutputParser class. 
        
        Returns:
            LLMOutputParser: an LLMOutputParser object. 
        
        Note: 
            use parser.parse(text) to obtain the result. 
        """
        pass

    @abstractmethod
    def parse_generated_texts(self, texts: List[str], parser: Optional[Type[LLMOutputParser]]=None, **kwargs) -> List[LLMOutputParser]:
        pass 
    
    def generate(
        self,
        prompt: Optional[Union[str, List[str]]] = None,
        system_message: Optional[str] = None,
        messages: Optional[Union[List[dict],List[List[dict]]]] = None,
        parser: Optional[Type[LLMOutputParser]] = None,
        **kwargs
    ) -> Union[LLMOutputParser, List[LLMOutputParser]]:
        
        """
        generate LLM output(s) for (a) prompt(s)/messages and parsed the result into an LLMOutputParser object. 

        Args:
            prompt (Union[str, List[str]]): the input to the LLM. 
            system_message (str): the system message for the LLM. 
            messages: (Union[List[dict],List[List[dict]]]): the chat message for the LLM. 
            parser (Optional[Type[LLMOutputParser]]): A LLMOutputParser (sub)class used to parse the LLM output.
                This class should implement .parse() method to parse the output. If None, LLMOutputParser will be used by default.
        
        Note:
            Either prompt or messages must be provided. Raise an error if both prompt and messages are provided or none of them is provided. 
            If parser is None, use LLMOutputParser by default. 
            Need to calculate the cost of an LLM call!
        """
        pass


__all__ = ["LLMConfig", "BaseLLM"]

